package Java2Project;

public class PolyMorExam {

	public static void main(String[] args) {

		Animal ani_1 = /*(Animal) : 자동으로 형변환*/ new Cat(); 
		// = 부모타입의 변수는 자식객체를 가리킬 수 있다. (= 자식객체의 주소값을 담을 수 있다.)

		// Cat cat1 = new Animal(); // = 자식타입의 변수는 부모객체를 가리킬 수 없다. (= 부모객체의 주소값을 담을 수
		// 없다.)

		Cat cat = (Cat) ani_1; // cat에 ani_1의 주소값을 담을 수는 있음 !
		// 컴파일러가 걱정해서 빨간줄 치는거니까 (Cat)이라고 강제형변환 시키면 됨
		
		Cat ani_2 = cat;
		
//		Cat cat1 = (Cat)new Animal("",0); // 부모 주소값은 자식타입의 변수에게 절대 줄 수 없음 ! 형변환 될 수 없음 !
		
		ani_1.howling();
		// ani_1.lick(); -> 오류 lick 타입을 가리킬 수 없다. 
		cat.howling(); // 오버라이딩 하지 않았다면 운다가 나왔을 것임. 오버라이딩 했기 때문에 야옹이 나온것임 
		cat.lick();
		System.out.println("끝!");

		/*
		 * 다향성이 어려운 이유 멤버필드 때문 멤버필드는 무조건 은닉화(private, 그래서 다향성 몰라도 됨)
		 * 
		 * 메소드 기준으로 다향성 기억하기
		 * 
		 * 1. 부모타입의 변수는 자식객체를 가리킬 수 있다. (= 자식객체의 주소값을 담을 수 있다.) 
		 * 2. 자식타입의 변수는 부모객체를 가리킬 수 없다. (= 부모객체의 주소값을 담을 수 없다.) + 자신의 타입의 변수는 자신의 객체를 가리킬 수 있다.
		 * 3. 타입은 아는 메소드만 호출할 수 있다. 호출이 되었다면 기준은 객체이다.
		 * 
		 * 자식은 부모와 같거나 더 많이 알 수 있다. 자식은 부모보다 적은 정보를 가지지 않는다. 
		 * 여기서는 cat이 animal보다 더 많은 정보를 가질 수 있다. 
		 */

	}

}
